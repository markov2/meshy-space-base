=short

<p>The <i>publication</i> is a <code>ms:unit</code> which describes
the (network) location where bytes can be collected.  It publishes
<SCHEMA>ms:collection</SCHEMA>s of <SCHEMA>ms:product</SCHEMA>s
(in bulk).</p>

=schema

==xml
<element name="publication" type="_publication" substitutionGroup="ms:unit" />

<complexType name="_publication">
  <complexContent>
    <extension base="ms:_unit">
      <sequence>
        <choice>
           <element name="address" type="anyURI" />
           <element name="blob" type="string" />
        </choice>
        <element name="collection" type="ms:_ref" minOccurs="0" maxOccurs="unbounded" />
      </sequence>
    </extension>
  </complexContent>
</complexType>
==end

=description

<p>See the <i>publication</i> as an exposition of (<i>collections</i> of)
data (groups of bytes) which you can get.  In most cases, you have
to download data from an <i>address</i>.  In other cases, you get a
<i>blob</i> with bytes containing everything you MAY need immediately.</p>

=element address

<p><i>Downloads</i> specify an access point to collect data.  This may
produce the data dynamicly, but may also be a file on local disk.
Addresses specified for the <i>collections</i> are relative to the
address of the publication they use.</p>

<p>As many parameters as possible should be encoded in uri according to
their scheme.  See the
<a href="https://en.wikipedia.org/wiki/List_of_URI_schemes">list of URI
schemes on Wikipedia</a>.

=element collection

<p>The <code>collection</code> refers to a <SCHEMA>ms:collection</SCHEMA>
unit.  One publication MAY offer many collections, which contain more or less
heterogenous sets of products.  The same collection of
products MAY be distributed via multiple <i>publications</i>.</p>

<p>The collection description MAY be huge, therefore is included by reference
(to be loaded on demand) not in-lined.</p>

=example publication with data remote, fetch via http address

==xml
<ms:publication ms:id="cc:http">
  <ms:address>https://commoncrawl.s3.amazonaws.com</ms:address>
  <ms:collection ms:ref="cc:crawl-data" />
</ms:publication>
==json
"ms:publication": {
    "ms:id": "cc:http",
    "ms:address": "https://commoncrawl.s3.amazonaws.com",
    "ms:collection": { "ms:ref" : "cc:crawl-data" }
}
==end

=example single product part in publication via blob

==xml
<ms:publication ms:id="myns:data">
  <ms:blob>
ewogICAiQ29udGFpbmVyIiA6IHsKICAgICAgIkNvbXByZXNzZWQiIDogdHJ1ZSw
ZnNldCIgOiAiNjAwOTk3NTgzIiwKICAgICAgIkZpbGVuYW1lIiA6ICJDQy1NQUl
bnQtTGVuZ3RoIiA6ICIyMDEiCiAgICAgIH0sCiAgICAgICJGb3JtYXQiIDogIld
fQo=
  </ms:blob>
</ms:publication>
<ms:part ms:for="myns:signature">
  <ms:resource ms:ref="myns:data">
    <ms:format>mime-type:application/signature</ms:format>
    <ms:encoded>gz.base64</ms:encoded>
  </ms:resource>
</ms:part>
==end

<p>The <code>resource</code> reference does not contain an <i>address</i>
so refers to the whole thing.  The <code>encoded</code> explains the
applied transport encoding.  <code>format</code> explains what kind of
data you get when you undo the transport encoding.  The result probably
has some serialization of its own, which is out of scope for MSI.</p>

=example publication with complex data in-lined, via blob

<p>First have a look at the simpler example, just here above.  Now
with a very complex data blob, which contains multiple settings,
amongst them a collection of signatures packed as uncompressed
<code>tar</code> archive.</p>
==xml
<ms:publication ms:id="myns:data">
  <ms:blob>ewogICAiQ29udGFpbmV...YXQiIDogIldfQo=</ms:blob>
  <ms:collection ms:ref="myns:settings" />
</ms:publication>
<ms:collection ms:id="myns:settings">
  <ms:resource ms:ref="myns:data">
     <ms:encoded>zip.base64</ms.encoded>
  </ms:resource>
  <ms:collection ms:ref="myns:signatures" />
  <ms:collection ms:ref="myns:mail-addresses" />
</ms:collection>
<ms:collection ms:id="myns:signatures">
  <ms:resource ms:ref="myns:settings">
    <ms:address>signatures.tar</ms:address>
    <ms:format>mime-type:application/tar</ms:format>
  </ms:resource>
</ms:collection>
<ms:product ms:id="myns:SDJOIUEHIUHI-sig">
  <ms:resource ms:ref="myns:signatures">
    <ms:address>work.sig</ms:address>
    <ms:format>mime-type:application/signature</ms:format>
  </ms:resource>
</ms:product>
<ms:product ms:id="myns:SDJOIUEHIUHI">
  <ms:name>Invoice 2021-001</ms:name>
  <ms:part ms:for="myns:email" ms:ref="myns:..." />
  <ms:part ms:for="myns:signature" ms:ref="myns:SDJOIUEHIUHI-sig"/>
</ms:product>
==end
<p>This looks very complex, but that's because the data structure
design is very complex.  Remember that each collection might be huge as
well: above is relatively little overhead to be able to handle all
situations equally well.</p>

<p>The <code>settings</code> collection may only use a subset of bytes
from the blob, giving an <code>address</code> with a byte range (counts
non-blank characters).</p>
